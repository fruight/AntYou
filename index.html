<!DOCTYPE html>
<html>
	<head>
		<title>AntYou</title>
	</head>
	<body>
		<canvas id='c'></canvas>
		<script type='application/javascript'>
/* author:	fruight<fruight@gmail.com>
 * 
 * AI-game inspired by AntMe
*/
(function(){
	console.log('startSetup');
	console.time('main');
	//init
	document.body.style.margin = '0px';
	document.body.style.overflow = 'hidden';
	var w = window.innerWidth;
	var h = window.innerHeight;
	var c = document.getElementById('c');
	var C = c.getContext('2d');
	c.width = w;
	c.height = h;
	c.style.width = '100%';
	c.style.height = '100%';
	var stats = {
		t0:new Date().getTime()
		,now:new Date().getTime()
		,dt:0
		,frame:0
		,fps:0
	}
	var config = {
		fps:40
		,maxPopulation:500
	}

	//settings
	var roles = [
		{size:15, speed:2, shape:'ant:F', ai:{
		 	idle:function(){
				me.log.push(stats.frame+': idle()');//TODO dont log repeatedly and log falling asleep
				me.stack.push(function(){me.ai.idle();});
				me.stack.push(function(){ai.go(100);});
				me.stack.push(function(){ai.turn(Math.random()*Math.PI-Math.PI/2);});
			}
		}}
		];

	//global ai functions
	var get = {
		angleTo:function(x,y){
			var t=Math.atan((me.y-y)/(x-me.x))-me.heading+(x<me.x?Math.PI:0);
			return t>Math.PI?t-2*Math.PI:(t<-Math.PI?t+2*Math.PI:t);
		}
		,distanceTo:function(x,y){
			return Math.sqrt(Math.pow(x-me.x,2)+Math.pow(y-me.y,2));
		}
	};
	var ai = {//TODO make a global default actor that supersedes all custom roles to simplify namespace
		go:function(d){
			me.log.push(stats.frame+': go('+d+')');
			if(d<=me.speed){
				me.x += d*Math.cos(me.heading);
				me.y -= d*Math.sin(me.heading);
			}else{
				me.x += me.speed*Math.cos(me.heading);
				me.y -= me.speed*Math.sin(me.heading);
				me.stack.push(function(){ai.go(d-me.speed);});
			}
		}
		,goTo:function(x,y){
			me.log.push(stats.frame+': goTo('+x+','+y+')');
			if(me.x===x && me.y===y){
			}else{
				me.stack.push(function(){ai.slideTo(x,y);});
				me.stack.push(function(){ai.go(Math.sqrt(Math.pow(x-me.x,2)+Math.pow(y-me.y,2)));});
				me.stack.push(function(){ai.turnTo(x,y);});
			}
		}
		,slide:function(a,d){//THINK call it 'strafing' instead?
			me.log.push(stats.frame+': slide('+a+','+d+')');
			var speed = me.speed/5;
			if(d<=speed){
				me.x += d*Math.cos(me.heading+a);
				me.y -= d*Math.sin(me.heading+a);
			}else{
				me.x += speed*Math.cos(me.heading+a);
				me.y -= speed*Math.sin(me.heading+a);
				me.stack.push(function(){ai.slide(a,d-speed);});
			}
		}
		,slideTo:function(x,y){
				me.stack.push(function(){ai.slide(get.angleTo(x,y),get.distanceTo(x,y));});
		}
		,turn:function(a){
			me.log.push(stats.frame+': turn('+a+')');
			var t=me.speed*Math.PI/90;
			if(Math.abs(a)<=t){
				me.heading += a;
			}else if(a>0){
				me.heading += t;
				me.stack.push(function(){ai.turn(a-t);});
			}else{
				me.heading -= t;
				me.stack.push(function(){ai.turn(a+t);});
			}
		}
		,turnTo:function(x,y){
			me.log.push(stats.frame+': turnTo('+x+','+y+')');
			me.stack.push(function(){ai.turn(get.angleTo(x,y));});
		}
		,sleep:function(t){
			if(t<=1){me.log.push(stats.frame+': wakeup');}
			else if(t===undefined){me.stack.push(function(){ai.sleep();});}
			else{me.stack.push(function(){ai.sleep(t-1);});}
		}
	}

	//setup
	var actors = [];
	var me = undefined;
	for(var i=0;i<config.maxPopulation;i++){
		actors[i] = {};
		actors[i].i       = i;
		actors[i].x       = Math.random()*w;
		actors[i].y       = Math.random()*h;
		actors[i].heading = Math.random()*2*Math.PI;
		actors[i].role    = Math.floor(Math.random()*roles.length);
		actors[i].size    = roles[actors[i].role].size;
		actors[i].speed   = roles[actors[i].role].speed;
		actors[i].shape   = roles[actors[i].role].shape;
		actors[i].ai      = roles[actors[i].role].ai;
		actors[i].stack   = [function(){me.ai.idle();}];
		actors[i].log     = [stats.frame+': init'];
	}

	//main loop
	(loop = function(){
		//console.time('loop');//DEBUG
		//console.count('loop');//DEBUG
		window.setTimeout(loop, 1000/config.fps);
		stats.dt = new Date().getTime()-stats.t0-stats.now;
		stats.now += stats.dt ;
		stats.frame++;
		for(var i=0;i<actors.length;i++){
			//calculate actions
			me=actors[i];
			actors[i].stack.pop()();
			while(actors[i].log.length>=2000){actors[i].log.shift();}//limit logsize
			//wrap the canvas
			if(actors[i].x < 0){actors[i].x = w;}else
			if(actors[i].x > w){actors[i].x = 0;}
			if(actors[i].y < 0){actors[i].y = h;}else
			if(actors[i].y > h){actors[i].y = 0;}
			//keep heading in valid range
			while(actors[i].heading >= 2*Math.PI){actors[i].heading -= 2*Math.PI;}
			while(actors[i].heading <= 0){actors[i].heading += 2*Math.PI;}
		}
		//draw all actors
		C.clearRect(0, 0, w, h);
		//C.beginPath();for(var i=100;i<w;i+=100){C.moveTo(i,0);C.lineTo(i,h);}for(var i=100;i<h;i+=100){C.moveTo(0,i);C.lineTo(w,i);}C.stroke();//DEBUG grid
		//C.beginPath();C.moveTo(w/2,h/2-10);C.lineTo(w/2,h/2+10);C.moveTo(w/2-10,h/2);C.lineTo(w/2+10,h/2);C.stroke();//DEBUG center
		for(var i=0;i<actors.length;i++){draw(actors[i]);}
		C.clearRect(0,0,260,10);
		C.fillText('time:'+stats.now+' ms | frame:'+stats.frame+' | fps:'+(Math.round(stats.fps=(stats.fps*49+100000/stats.dt)/50)/100),2,9);
		//console.timeEnd('loop');//DEBUG
	})();

	//drawing function
	function draw(actor){
		var s = Math.sin(actor.heading);
		var c = Math.cos(actor.heading);
		var r = actor.size/2;
		if(actor.shape===undefined){actor.shape='round';}
		var shape   = actor.shape.indexOf(':')===-1?actor.shape:actor.shape.substring(0,actor.shape.indexOf(':'));
		var options = actor.shape.indexOf(':')===-1?'':actor.shape.substring(actor.shape.indexOf(':')+1);
		C.beginPath();
		if(shape==='round'){
			C.arc(actor.x, actor.y, r, 0, 2*Math.PI, true);
		}else if(shape==='square'){
			C.moveTo(actor.x + c * r - s * r, actor.y - s * r - c * r);
			C.lineTo(actor.x - s * r - c * r, actor.y - c * r + s * r);
			C.lineTo(actor.x - c * r + s * r, actor.y + s * r + c * r);
			C.lineTo(actor.x + s * r + c * r, actor.y + c * r - s * r);
			C.lineTo(actor.x + c * r - s * r, actor.y - s * r - c * r);
		}else if(shape==='diamond'){
			C.moveTo(actor.x + c * r, actor.y - s * r);
			C.lineTo(actor.x - s * r, actor.y - c * r);
			C.lineTo(actor.x - c * r, actor.y + s * r);
			C.lineTo(actor.x + s * r, actor.y + c * r);
			C.lineTo(actor.x + c * r, actor.y - s * r);
		}else if(shape==='tri'){
			C.moveTo(actor.x + c * r, actor.y - s * r);
			C.lineTo(actor.x - s * r - c * r, actor.y - c * r + s * r);
			C.lineTo(actor.x - c * r + s * r, actor.y + s * r + c * r);
			C.lineTo(actor.x + c * r, actor.y - s * r);
		}else if(shape==='arrow'){
			C.moveTo(actor.x + c * r, actor.y - s * r);
			C.lineTo(actor.x - s * r - c * r, actor.y - c * r + s * r);
			C.lineTo(actor.x, actor.y);
			C.lineTo(actor.x - c * r + s * r, actor.y + s * r + c * r);
			C.lineTo(actor.x + c * r, actor.y - s * r);
		}else if(shape==='ant'){ //TODO add legs and antennae
			C.arc(actor.x + c*r/2, actor.y - s*r/2, r/3, 0, 2*Math.PI, true);
			C.moveTo(actor.x + r/4, actor.y);
			C.arc(actor.x, actor.y, r/4, 0, 2*Math.PI, true);
			C.moveTo(actor.x - c*r/2+r/3, actor.y + s*r/2);
			C.arc(actor.x - c*r/2, actor.y + s*r/2, r/3, 0, 2*Math.PI, true);
			C.moveTo(actor.x - s*r, actor.y - c*r);
			C.lineTo(actor.x + s*r, actor.y + c*r);
			C.moveTo(actor.x - s*r - c*r/2, actor.y - c*r + s*r/2);
			C.lineTo(actor.x + s*r + c*r/2, actor.y + c*r - s*r/2);
			C.moveTo(actor.x - s*r + c*r/2, actor.y - c*r - s*r/2);
			C.lineTo(actor.x + s*r - c*r/2, actor.y + c*r + s*r/2);
		}else{ //warn for unknown shapes and fall back to round
			console.warn('unknown shape: "'+actor.shape+'", falling back to "round:'+options+'"');//TODO avoid multiple warnings for same error, give info
			actor.shape = 'round:'+options;
		}
		//C.moveTo(actor.x, actor.y);C.lineTo(actor.x-actor.speed*10*c, actor.y+actor.speed*10*s);//DEBUG add a trail to show speed and heading
		//draw filled or hollow
		if(options.match('F')){C.fill();}
		C.stroke();
	}

	//end
	console.timeEnd('main');
	console.log('endSetup');
})();
		</script>
	</body>
</html>
